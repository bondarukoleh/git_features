There are 3 major states in git
Working directory - where your unindex changes are
Index - where your changes added to index
Repository - commited changes to repository.

WORKING WITH FILES
#To update file in index avoid OS
$>git update-index --chmod=+x <file>

#Or if file isn't in index yet
$>git add --chmod=+x <file>

#to add file avoid .gitignore (force)
$>git add -f .idea/../someNeededFile

#to rename
$>git mv file1 file2

WORKING WITH COMMIT
#To see the commit
$>git show <commitID>
#Current commit
$>git show --pretty=fuller

#To set athor of commit. You will be commiter but code author - can be some one else
$>git commit --author='John Snow <johnSnow@gmail.com>' --date='...' 

#to discard changes from index
$>git reset HEAD .idea

#to add some code from file
$>git add -p <file>

#To commit with add, BUT This won't work with untracked (not in index) files.  
$>git commit -am 'message'

#Commit specific file, file, directories.
$>git commit -m 'message' <file/files/dir>

$>git commit -v (verbose)
Will add in commit message difference between indexed changes that we going to commit
and HEAD of branch, it will add diff under cizors part - so it won't appear in commit
message, it's ust for you, to better understand what you will commit. 

INDEX
#git add . -> adds only current directory
#git add -A -> no matter where are you, adding all from root. 

#To remove directory, automatically git will add this change to index
$>git rm -r dirtoDelete

Remove file from index:
$>git reset ./someFile.js

#to remove from index - but make untracked
$>git rm -r --cached file/dirToRemoveFromCache

BRANCH
#Cchery pick - to get some commit from branch and merge it with other branch 

#branch - it's just a link to some commit. You can check it in .git/refs/heads/
# git branch -v shows the commit on what commit branch is looking

#.git/refs/HEAD - current branch

After you done a commit - it contains information about previous commits on the base of it was created,
and HEAD link points on last commit. Last commit in branch - called TOP of the branch.
So important thing - 
TOP - is the last commit in branch, branch is pointing on that commit.
HEAD - is where you are, and in most cases - HEAD is pointing on the last commit in branch - so 
it's automatically pointing on TOP of hte branch. But if you set the HEAD to point to some other commit -
HEAD won't be pointing on the TOP of the branch.

Commits that lead to the state of current branch - belongs to branch.
For example in maser we have 3 commits, than we checkout to feature and 
made 2 commits more. all 5 commits belongs to feature branch, since thay lead
to it state, and 3 commits belongs to master branch.

#will delete all uncommitted changes
$>git checkout -f branch 

#will checkout on commit that HEAD refers, means return the branch in latest commit's state
#Even that was added to index
$>git co -f HEAD (or git co -f, if the branch isn't set - will grab current branch HEAD)

#stashes all changes
$>git stash

#apply changes on current branch (no matter that you stashed changes in other branch)
$>git stash pop

Checkout will be forbidden only if git should replace some changes from branchA in branchB,
if co could be done without any changes - it will be done.
Also If you on develop and realise that changes should have separate branch -
it's not a problem to create separate branch by git co -b newBranch.
TOP of develop branch and HEAD of newBranch is pointing on the same commit - so the branches are same,
but you have now all changes in newBranch, and you can easily continue.

Situation. You've done a 2b, 3c, 4d commits in develop, and realise that they should be in separate
branch. One of ways to solve this:
Create and checkout to a branch where you want these commits to be:
1. $>git checkout -b extraCommits (now these commits in two branches develop and extraCommits);
Recreate a develop branch with TOP on commit before you made a 1a, 2b, 3c commits:
2. $>git branch -f develop 1a (force needed because git won't let you to create existing branch)
That's all, now branch extraCommits has 2b, 3c, 4d commits, and develop is on 1a commit.
If you change your mind - you can set develop back
$>git branch -f develop extraCommits (instead 4d commit, you can set a branch name,
it will set TOP of develop to the commit that extraCommits' HEAD is pointing to)

Same stuff we can do with checkout.
1. $>git checkout -b extraCommits
2. $>git checkout -B develop 1a (-B - for existing branch, it will set HEAD for develop to 1a);

Detached HEAD.
You can switch to any commit that you like
$>git co 3c
But be aware that this is state of detached HEAD, means you are not in branch
your HEAD is pointing on commit, not on branch's TOP. And if you will do a commit in this state - it will be
nowhere, if you like to continue working from this state - you can create a new branch for this
commit.
$>git cob/branch branchFromDetached
Or if you've made detached commit 3c-detached, you can cherry-pick it to your branch, it takes this commit and 
move it to your branch.
$>git cherry-pick ej32

To checkout some file from previous commit - in current branch
git co 1mj3n4 neededFileFromPreviousCommit.

When you pass a commit id / or branch name (with is equal to commit branch TOP pointing to)
and pass a file name/directory/few files name - git doesn't switch a branch, it returns a file
to state of that commit.

If you want to switch file back to current directory state
$>git co HEAD neededFileFromPreviosCommit // returns file from repository to index and working directory (current branch)
or $>git co neededFileFromPreviosCommit // returns from index to working directory

if folder named develop and you want to revert it to current state, you need to add --
$>git co -- develop (everything after -- counts as a path, not branch)

BRANCH HISTORY
to see in one line
$>git log --oneline

you can pass a commit or branch
$>git log 32fj/featureMranch

see datailed commit info, by default - it will be HEAD, but we can pass a commit
$>git show /featureBranch/234fjs

tilda - to see one commit behind, --quiet - to see only general info
$>git show HEAD~ --quiet (or you can pass a count of titldes HEAD~3)

A shourtcut for HEAD is at sighn
$>git show @~2 (Windows - "@~")

To see whole file from commit before
$>git show @~:fileToshow

If you index some file and change something and want to see index version of file
$>git show :fileToshow

If you want to see the commit but remember ony commit message - you can run.
It takes a lates commit wih these words. Branch is not counting.
$>git show :/'some Words From Commit'

MERGE
Checkout in branch you want to merge in. BE CAREFULL this will create a merge commit.
$>git checkout develop
$>git merge featureBranch

git helping us witha merge - storing last before merge commit in current branch in ORIG_HEAD
$>cat .git/ORIG_HEAD - stores last commit
to return develop in previous state we cat use it
$>git branch -f develop ORIG_HEAD - will rectreate develop with HEAD on ORIG_HEAD commit.

DELETE
Difference between -d and -D - is
-d needed when you've already megre featureBranch with develop - and you don't want it since since 
TOP of feature branch is now in develop.
But if featureBranch - is not merged yet, and it's a risky operation - git won't let you to do it. 
Because commits from deleted branch - will be unreachable. But if you still want to do it -D.
If you want to revert deletion - in short time it's posible, you can recreate a branch with HEAD
pointing on that commit that you want from deleted branch
$>git checkout -b featureBranch 123d

REFLOG
Git logs every movement. You can checkout every change HEAD link for example. All logs are in .git/logs/
to see logs for HEAD
$>cat .git/logs/HEAD
But there is a special command
$>git reflog (by default will show for HEAD, but we cat pass an argument)
$>git reflog develop
But if you've delete branch - here won't be any info about deleted branch (it will be here .git/logs/HEAD)

So to restore branch on some commit you cat
$>git checkout -b lostBranch "HEAD@{5}" (quotes for shell, {number} - it's a count of commit in logs)

reflog - it's an alias got log. So many log flags - is suitable here
$>git reflog (same as git log --online -g)
$>git reflog --date=iso (with date)

fast checkout on previus branch via reflog, but be aware that branch should existing
$>git checkout @{-1} (1 checkout back, {-2} - two);
or even more shorter
$>git checkout - (but in UNIX as far as I get)

Involve garbadge collector. Amount of days unreachable commits are storing is settet in settings.
$>git gc

Show unreachable objects
$>git fsck --unreachable

While TOP of any branch is existing - exists all their parents, and we can restore deleted information.
If you need to clear branch from fat files, or clean commits from that files you have
git filter-branch, or third-party BFG, it can help to filter commits, of make them unreachable, so 
garbadge collector will delete them.

TAG
Simple tags:
We can mark a commit with a tag. It's simple marker of commit, nothing more, cool thing about tag - is
that it's not moving anywhere. It's like a fact.  
$>git tag release_0.0.1 release_commit

And we can create a branch using tag (link to some commit)
$>git checkout -b fix_release_0.0.1 release_0.0.1
delete tag
$> git tag -d release_0.0.1

Tags has a lot of filter flags.
Tags with annotation, different from simple - contain information message, date, author.
#>git tag -a some_info_tag 463hki (or git tag -a -m 'It is a short message about this tag'
some_info_tag 463hki)

to check the message, we can
$>git show some_info_tag

With git describe - we cat check the nearest tag of the commit.
$>git describe release_commit (will show release_0.0.1 tag)

$>git describe HEAD
info_tag-2-g461dc07 (says that nearest tag is info_tag, we are 2 commit ahead of it,
and commit where we are)

With git archive we cat do archive from some commit. And also we can use tag here.
$>git archive some_info_tag
$>git archive -o ./temp/info_tag-2-g461dc07.zip some_info_tag (-o where to make an archive)

to unzip
$>unzip ./temp/info_tag-2-g461dc07.zip

RESET
--HARD
To revert branch TOP to some commit we can use reset.
Simpliest way to do it:
$>git reset --hard sdj23 (previous commit) same as
$>git reset --hard @~ (@ - HEAD, ~ - previous commit)

This will make latest TOP of the branch - unreachable from branch.
It will be deleted with time. reset will delete working directory and index changes,
and set HEAD and TOP to previous commit.

To undo reset we can reset once more but to latest TOP.
$>git reset --hard 34s3d (latest commit)
If we forgot commit id - we can find it in reflog
$>git reflog master
Or there is another way, git before reseting branch HEAD - logs commit to .git/ORIG_HEAD, so
$>git reset --hard ORIG_HEAD

--SOFT
$>git reset --soft @~
Will move HEAD to previous commit, and it will compute delta between latest and previous commit
and put it in index. So all changes that made in latests commit will now be in index.
Basicaly it behaves like a hard but keeps changes in index.

To revert reset we can do same as with hard.
$>git reset --soft ORIG_HEAD

So we softly reset to previous commit and make some changes. We should add files that changed in index
and make a new commit. We fix our errors in latest commit, and want to use a commit message from latest
to not type it once more.
$>git commit -c ORIG_HEAD (-c - we can change commit message from latest, -C - it will grap message as it is.)
Keep in mind that -c/-C - takes not only message but author also and most important date of latest commit.
And git log/show shows that commits are identical witch can confuse you.
To get a full information about commit use:
$>git log --pretty-fuller

If you want only commit message:
$>git commit -C ORIG_HEAD --reset-author

AMEND
This is special for changing latest commit. it's the same thing that we done before.
$>git commit --amend --reset-author --no-edit (to not involde a text redactor for changing the message)
same as:
$>git reset --soft ORIG_HEAD
$>git commit -C ORIG_HEAD --reset-author

So it's just softly reset HEAD to previous commit, than commits all changes from index.
But soft reset is more powerfull, it gives you ability to make with branch what ever you want.
For example you have done 1,2,3 commits, and want to make them 1.
$>git reset --soft 0commit
Your HEAD on state where you didn't do anything, but all changes from 1,2,3 commits in index now.
You make a new commit
$>git commit 4
HEAD is on 4th commit where all your changes is commited. Here you're are, one commit from 1,2,3
But be aware, it will help to change only last commit. You can not change 2th commit wand nothing more.
It's up to rewriting git history - and for that purpose - rebase is.

--MIXED
(it's a default flag of reset command, so you may not type it)
This reset revert repository and index, but delta between latest commit and previous now lives in 
working directory, so it's same as soft but changes now not in index but in working directory.

Also it's a usefull thing to clear index file.
$>git reset HEAD (same as $>git reset --mixed HEAD or even $> git reset (if no commit passed - then it's HEAD));
Reset as we know should revert repository and index to some commit and put changes in working directory.
But since we tell reset on HEAD that means revert repository and index to latest commit - witch
means remove all changes from index.
Also we can tell what file should be removed from index
$>git reset ./someFile.js
$>git reset 23h5 ./someFile.js (reset file in index to some commit)
if you want these changes not only in index - checkout
$>git checkout 23h5 ./someFile.js

--KEEP
Will revert to some commit, but changes that now in working directory it will try to keep.
Be carefull, if file was changed between commits - it will revert it, without save.
So it mostly like --hard but with keeping changes that possible in working directory.
If it sees that it cannot revert some files without conflicts - it won't do it. 
So as far as I get - if you wand to reset a file, but keep your changes in working directory - 
that's your choise.
One more feature - it's make reset --keep without arguments, means to current HEAD.
It will remove all changes from index, but keep all changes that in this moment in working directory,
useful when you merge something.
$>git reset help - will show also a table what reset will do in different situations.

--MERGE
Aimed on reseting erronneous merge.
Reseting repository and index, keeps changes in working directory if it can.
If changes for some file in index - and we reseting on one commit back - chnges will be
deleted from index and from working directory. But if no changes in index - changes for
file - will be saved in working directory.
Most frequent usage - without any argument
$>git reset --merge
It will delete all changes in index, for rest files - changes will be in working directory.
Can be usefull in merge process.

CLEAN
For deleting not tracked files and directories. If you have some generated stuff or downloaded
- it will help you.
$>git clean -d(for directories)x(for files even in gitignore)f(to make it work)

So for cleanup whole project we need to reset hard on HEAD, and make clean -dxf

DIFF
$>git diff 3jo3i 64ml5 (or develop feature, or develop..feature)
It will show diff blocks, hangs, that will show difference between two branches:
diff --git a/gitInfo.txt b/gitInfo.txt (showing that develop branch is - a, and feature is b)
index 56cb5e6..779c279 100644 (hash sum of gitInfo.txt in develop is 56cb5e6, in feature - 779c279,
   100644 - file type, 100 - regular file, 644 - not executable);
--- a/gitInfo.txt (name file, if it's not deleted, renamed, or changed somehow)
+++ b/gitInfo.txt
@@ -1,56 +1,44 @@ hang headre(sometimes it's here) (If in develop you'll change, as it shows in termminal,
from 1st row, 56th rows - you'll get file that you've got in feature and it will be from 1st row till 44th row.)

$>git diff develop...feature
Will compare what was changed in feature from commit that it was branched from develop.
Means it will compare commit where feature was born with TOP of feature.

$>git diff fk4g (HEAD for example)
Will show difference between current working directory changes wih commit.
git diff - defferent with git diff HEAD, without argument - it will show diff with cyrrent index, not commit.
Be aware that these types of commands - ignore untracked files.

$>git diff --cached/--staged HEAD
Show difference beetwen index and HEAD. Useful to see what we will commit after we add changes in index.

$>git diff (nothing - to compare with index, HEAD to compare with head) file.js
$> git diff develop feature file.js (you can add a few files here to save time)
Show changes of some particular file, depending on what you want to see.

$>git diff --name-only e24412
show only files that changed, after that you can look more detailed for file you're interested in.

$>git diff master:file1.js develop:file2.js
compare two different files from two different commits.

$>git diff --no-index file1.js file2.js
compare any two files on machine, no matter what it is, and in our repository or not.

$>git diff --word-diff (--color-words - will show only words without brackets stuff)
compare sentenses, with comfortable, clear difference.

Also you can exend local git config .git/config - with new diff features. i.e. add markdown
hendler (driver) in diff.
[diff "markdown"]
        # POSIX extended
        xfuncname = "^#+[[:space:]]+.+$" (it's for deff header, just a tip to diff be more readable)
        wordRegex = "\\*+|[^[:space:]*]+" (for word, how git will understand that this is a word)
and now you can add a *.md diff=markdown in your .gitattributes.

Also you can setup diff for images, and other non text files. 
For that you can use non-git utilites, and set them to config file
[diff "myOwnDiffTool"]
      command = sh -c 'icdiff "$1" "$4"'
and in gitattributes *.png diff = myOwnDiffTool
Means, that when I will call diff on png file, git will pass arguments (path to diff files,
commits, hashsum and others) to icdiff tool, but we want to have only pathes to files, thats
why we pass to icdiff first and forth arguments.

LOG
Shows commits reachable from HEAD

$>git log
By default it runs with flag --pretty=medium (commitID, author, date, commit message)
$>git log --pretty=oneline (gives us commitID and message) --abbrec-commit (to make commitID short) 
same as 
$>git log --oneline

log is very customizable. i.e.
$>git log --pretty=format:'%h %cd | %s%d [%an]'
Show us custom log info where:
%h - short commitID
%cd - date
%s - commit message first line
%d - decorator string, pointing HEAD, branch etc.
[%an] - author in brackets
We can find all flags in git help log

Also we can edit collors. We can check them in git help config.
normal, black, red, green, yellow, blue, magenta, cyan and white
bold, dim, ul, blink, reverse, italic, and strike
$>git log --pretty=format:'%C(yellow)%h %C(red)%cd | %C(green)%s%d %C(dim green)[%an]'

See git log with changes.
$>git log --patch (-p)

$>git log master
Show commits from master

$>git log master develop --graph ($>git log --all --graph) 
Show branches commits lite tree, graph

$>git log feature ^master
same $>git log master..feature
or if you are in one of needed branch
master$>git log HEAD..feature (same as git log ..feature)
Show commits done after branching from master.
So it show feature commits unreachable from master

oposite:
master$>git log feature..
Shows master commits that isn't reachable from feature branch. cool.

$>git log master...feature --boundary --graph
... - commits reachable from master and feature, but not for both branches same time.
- boundary - will show the commit where branches where divided.

$>git log myFile.js (git log -p myFile.js - with changes made in that file,
--follow - if the file was changed, git findes changes for changed file also)
Shows commits where this file was changed.

If you wanted to see differentse between file in branches
$>git log feature..master myFile.js

Search for commits by message
$>git log --grep 'word from message'
$>git log --grep 'word from message' featureBranch (in some branch)
$>git log --grep 'thisWord|orThisWord' -P -i (Perl friendly reqexp, ignore case)

You want to find all commits where some function was added.
$>git log -GfunctionNameRegexp -p (p - show changes)

More important and pwerfull search - it's you wand to find all changes that was made
in some function. You need to add -L flag and set a regexp to start search from
and regexp where to end. Also it's usefull to set the file you want to search in.
$>git log -L '/<head>/','/<\/head>/':somefile.html

