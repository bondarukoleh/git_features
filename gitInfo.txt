There are 3 major states in git
Working directory - where your unindex changes are
Index - where your changes added to index
Repository - commited changes to repository.

WORKING WITH FILES
#To update file in index avoid OS
$>git update-index --chmod=+x <file>

#Or if file isn't in index yet
$>git add --chmod=+x <file>

#to add file avoid .gitignore (force)
$>git add -f .idea/../someNeededFile

#to rename
$>git mv file1 file2

WORKING WITH COMMIT
#To see the commit
$>git show <commitID>
#Current commit
$>git show --pretty=fuller

#To set athor of commit. You will be commiter but code author - can be some one else
$>git commit --author='John Snow <johnSnow@gmail.com>' --date='...' 

#to discard changes from index
$>git reset HEAD .idea

#to add some code from file
$>git add -p <file>

#To commit with add, BUT This won't work with untracked (not in index) files.  
$>git commit -am 'message'

#Commit specific file, file, directories.
$>git commit -m 'message' <file/files/dir>

$>git commit -v (verbose)
Will add in commit message difference between indexed changes that we going to commit
and HEAD of branch, it will add diff under cizors part - so it won't appear in commit
message, it's ust for you, to better understand what you will commit. 

INDEX
#git add . -> adds only current directory
#git add -A -> no matter where are you, adding all from root. 

#To remove directory, automatically git will add this change to index
$>git rm -r dirtoDelete

Remove file from index:
$>git reset ./someFile.js

#to remove from index - but make untracked
$>git rm -r --cached file/dirToRemoveFromCache

BRANCH
#Chery pick - to get some commit from branch and merge it with other branch 

#branch - it's just a link to some commit. You can check it in .git/refs/heads/
# git branch -v shows the commit on what commit branch is looking

#.git/refs/HEAD - current branch

After you done a commit - it contains information about previous commits on the base of it was created,
and HEAD link points on last commit. Last commit in branch - called TOP of the branch.
So important thing - 
TOP - is the last commit in branch, branch is pointing on that commit.
HEAD - is where you are, and in most cases - HEAD is pointing on the last commit in branch - so 
it's automatically pointing on TOP of hte branch. But if you set the HEAD to point to some other commit -
HEAD won't be pointing on the TOP of the branch.

Commits that lead to the state of current branch - belongs to branch.
For example in maser we have 3 commits, than we checkout to feature and 
made 2 commits more. all 5 commits belongs to feature branch, since thay lead
to it state, and 3 commits belongs to master branch.

#will delete all uncommitted changes
$>git checkout -f branch 

#will checkout on commit that HEAD refers, means return the branch in latest commit's state
#Even that was added to index
$>git co -f HEAD (or git co -f, if the branch isn't set - will grab current branch HEAD)

#stashes all changes
$>git stash

#apply changes on current branch (no matter that you stashed changes in other branch)
$>git stash pop

Checkout will be forbidden only if git should replace some changes from branchA in branchB,
if co could be done without any changes - it will be done.
Also If you on develop and realise that changes should have separate branch -
it's not a problem to create separate branch by git co -b newBranch.
TOP of develop branch and HEAD of newBranch is pointing on the same commit - so the branches are same,
but you have now all changes in newBranch, and you can easily continue.

Situation. You've done a 2b, 3c, 4d commits in develop, and realise that they should be in separate
branch. One of ways to solve this:
Create and checkout to a branch where you want these commits to be:
1. $>git checkout -b extraCommits (now these commits in two branches develop and extraCommits);
Recreate a develop branch with TOP on commit before you made a 1a, 2b, 3c commits:
2. $>git branch -f develop 1a (force needed because git won't let you to create existing branch)
That's all, now branch extraCommits has 2b, 3c, 4d commits, and develop is on 1a commit.
If you change your mind - you can set develop back
$>git branch -f develop extraCommits (instead 4d commit, you can set a branch name,
it will set TOP of develop to the commit that extraCommits' HEAD is pointing to)

Same stuff we can do with checkout.
1. $>git checkout -b extraCommits
2. $>git checkout -B develop 1a (-B - for existing branch, it will set HEAD for develop to 1a);

Detached HEAD.
You can switch to any commit that you like
$>git co 3c
But be aware that this is state of detached HEAD, means you are not in branch
your HEAD is pointing on commit, not on branch's TOP. And if you will do a commit in this state - it will be
nowhere, if you like to continue working from this state - you can create a new branch for this
commit.
$>git cob/branch branchFromDetached
Or if you've made detached commit 3c-detached, you can cherry-pick it to your branch, it takes this commit and 
move it to your branch.
$>git cherry-pick ej32

To checkout some file from previous commit - in current branch
git co 1mj3n4 neededFileFromPreviousCommit.

When you pass a commit id / or branch name (with is equal to commit branch TOP pointing to)
and pass a file name/directory/few files name - git doesn't switch a branch, it returns a file
to state of that commit.

If you want to switch file back to current directory state
$>git co HEAD neededFileFromPreviosCommit // returns file from repository to index and working directory (current branch)
or $>git co neededFileFromPreviosCommit // returns from index to working directory

if folder named develop and you want to revert it to current state, you need to add --
$>git co -- develop (everything after -- counts as a path, not branch)

To see with what branches current was merged
$>git branch --merged (oposite to --no-merged)

BRANCH HISTORY
to see in one line
$>git log --oneline

you can pass a commit or branch
$>git log 32fj/featureMranch

see datailed commit info, by default - it will be HEAD, but we can pass a commit
$>git show /featureBranch/234fjs

tilda - to see one commit behind, --quiet - to see only general info
$>git show HEAD~ --quiet (or you can pass a count of titldes HEAD~3)

A shourtcut for HEAD is at sighn
$>git show @~2 (Windows - "@~")

To see whole file from commit before
$>git show @~:fileToshow

If you index some file and change something and want to see index version of file
$>git show :fileToshow

If you want to see the commit but remember ony commit message - you can run.
It takes a lates commit wih these words. Branch is not counting.
$>git show :/'some Words From Commit'

DELETE
Difference between -d and -D - is
-d needed when you've already megre featureBranch with develop - and you don't want it since since 
TOP of feature branch is now in develop.
But if featureBranch - is not merged yet, and it's a risky operation - git won't let you to do it. 
Because commits from deleted branch - will be unreachable. But if you still want to do it -D.
If you want to revert deletion - in short time it's posible, you can recreate a branch with HEAD
pointing on that commit that you want from deleted branch
$>git checkout -b featureBranch 123d

REFLOG
Git logs every movement. You can checkout every change HEAD link for example. All logs are in .git/logs/
to see logs for HEAD
$>cat .git/logs/HEAD
But there is a special command
$>git reflog (by default will show for HEAD, but we cat pass an argument)
$>git reflog develop
But if you've delete branch - here won't be any info about deleted branch (it will be here .git/logs/HEAD)

So to restore branch on some commit you cat
$>git checkout -b lostBranch "HEAD@{5}" (quotes for shell, {number} - it's a count of commit in logs)

reflog - it's an alias got log. So many log flags - is suitable here
$>git reflog (same as git log --online -g)
$>git reflog --date=iso (with date)

fast checkout on previus branch via reflog, but be aware that branch should existing
$>git checkout @{-1} (1 checkout back, {-2} - two);
or even more shorter
$>git checkout - (but in UNIX as far as I get)

Involve garbadge collector. Amount of days unreachable commits are storing is settet in settings.
$>git gc

Show unreachable objects
$>git fsck --unreachable

While TOP of any branch is existing - exists all their parents, and we can restore deleted information.
If you need to clear branch from fat files, or clean commits from that files you have
git filter-branch, or third-party BFG, it can help to filter commits, of make them unreachable, so 
garbadge collector will delete them.

TAG
Simple tags:
We can mark a commit with a tag. It's simple marker of commit, nothing more, cool thing about tag - is
that it's not moving anywhere. It's like a fact.  
$>git tag release_0.0.1 release_commit

And we can create a branch using tag (link to some commit)
$>git checkout -b fix_release_0.0.1 release_0.0.1
delete tag
$> git tag -d release_0.0.1

Tags has a lot of filter flags.
Tags with annotation, different from simple - contain information message, date, author.
#>git tag -a some_info_tag 463hki (or git tag -a -m 'It is a short message about this tag'
some_info_tag 463hki)

to check the message, we can
$>git show some_info_tag

With git describe - we cat check the nearest tag of the commit.
$>git describe release_commit (will show release_0.0.1 tag)

$>git describe HEAD
info_tag-2-g461dc07 (says that nearest tag is info_tag, we are 2 commit ahead of it,
and commit where we are)

With git archive we cat do archive from some commit. And also we can use tag here.
$>git archive some_info_tag
$>git archive -o ./temp/info_tag-2-g461dc07.zip some_info_tag (-o where to make an archive)

to unzip
$>unzip ./temp/info_tag-2-g461dc07.zip

RESET
--HARD
To revert branch TOP to some commit we can use reset.
Simpliest way to do it:
$>git reset --hard sdj23 (previous commit) same as
$>git reset --hard @~ (@ - HEAD, ~ - previous commit)

This will make latest TOP of the branch - unreachable from branch.
It will be deleted with time. reset will delete working directory and index changes,
and set HEAD and TOP to previous commit.

To undo reset we can reset once more but to latest TOP.
$>git reset --hard 34s3d (latest commit)
If we forgot commit id - we can find it in reflog
$>git reflog master
Or there is another way, git before reseting branch HEAD - logs commit to .git/ORIG_HEAD, so
$>git reset --hard ORIG_HEAD

--SOFT
$>git reset --soft @~
Will move HEAD to previous commit, and it will compute delta between latest and previous commit
and put it in index. So all changes that made in latests commit will now be in index.
Basicaly it behaves like a hard but keeps changes in index.

To revert reset we can do same as with hard.
$>git reset --soft ORIG_HEAD

So we softly reset to previous commit and make some changes. We should add files that changed in index
and make a new commit. We fix our errors in latest commit, and want to use a commit message from latest
to not type it once more.
$>git commit -c ORIG_HEAD (-c - we can change commit message from latest, -C - it will grap message as it is.)
Keep in mind that -c/-C - takes not only message but author also and most important date of latest commit.
And git log/show shows that commits are identical witch can confuse you.
To get a full information about commit use:
$>git log --pretty-fuller

If you want only commit message:
$>git commit -C ORIG_HEAD --reset-author

AMEND
This is special for changing latest commit. it's the same thing that we done before.
$>git commit --amend --reset-author --no-edit (to not involde a text redactor for changing the message)
same as:
$>git reset --soft ORIG_HEAD
$>git commit -C ORIG_HEAD --reset-author

So it's just softly reset HEAD to previous commit, than commits all changes from index.
But soft reset is more powerfull, it gives you ability to make with branch what ever you want.
For example you have done 1,2,3 commits, and want to make them 1.
$>git reset --soft 0commit
Your HEAD on state where you didn't do anything, but all changes from 1,2,3 commits are in index now.
You make a new commit
$>git commit 4
HEAD is on 4th commit where all your changes is commited. Here you're are, one commit from 1,2,3
But be aware, it will help to change only last commit. You can not change 2nd, 3rd commit, only last nothing more.
It's up to rewriting git history - and for that purpose - rebase is.

--MIXED
(it's a default flag of reset command, so you may not type it)
This reset revert repository and index, but delta between latest commit and previous now lives in 
working directory, so it's same as soft but changes now not in index but in working directory.

Also it's a usefull thing to clear index file.
$>git reset HEAD (same as $>git reset --mixed HEAD or even $> git reset (if no commit passed - then it's HEAD));
Reset as we know should revert repository and index to some commit and put changes in working directory.
But since we tell reset on HEAD that means revert repository and index to latest commit - witch
means remove all changes from index.
Also we can tell what file should be removed from index
$>git reset ./someFile.js
$>git reset 23h5 ./someFile.js (reset file in index to some commit)
if you want these changes not only in index - checkout
$>git checkout 23h5 ./someFile.js

--KEEP
Will revert to some commit, but changes that now in working directory it will try to keep.
Be carefull, if file was changed between commits - it will revert it, without save.
So it mostly like --hard but with keeping changes that possible in working directory.
If it sees that it cannot revert some files without conflicts - it won't do it. 
So as far as I get - if you wand to reset a file, but keep your changes in working directory - 
that's your choise.
One more feature - it's make reset --keep without arguments, means to current HEAD.
It will remove all changes from index, but keep all changes that in this moment in working directory,
useful when you merge something.
$>git reset help - will show also a table what reset will do in different situations.

--MERGE
Aimed on reseting erronneous merge.
Reseting repository and index, keeps changes in working directory if it can.
If changes for some file in index - and we reseting on one commit back - chnges will be
deleted from index and from working directory. But if no changes in index - changes for
file - will be saved in working directory.
Most frequent usage - without any argument
$>git reset --merge
It will delete all changes in index, for rest files - changes will be in working directory.
Can be usefull in merge process.

CLEAN
For deleting not tracked files and directories. If you have some generated stuff or downloaded
- it will help you.
$>git clean -dxf (d - for directories) (x - for files even in gitignore) (f - to make it work)

So for cleanup whole project we need to reset hard on HEAD, and make clean -dxf

DIFF
$>git diff 3jo3i 64ml5 (or develop feature, or develop..feature)
It will show diff blocks, hangs, that will show difference between two branches:
diff --git a/gitInfo.txt b/gitInfo.txt (showing that develop branch is - a, and feature is b)
index 56cb5e6..779c279 100644 (hash sum of gitInfo.txt in develop is 56cb5e6, in feature - 779c279,
   100644 - file type, 100 - regular file, 644 - not executable);
--- a/gitInfo.txt (name file, if it's not deleted, renamed, or changed somehow)
+++ b/gitInfo.txt
@@ -1,56 +1,44 @@ hang headre(sometimes it's here) (If in develop you'll change, as it shows in termminal,
from 1st row, 56th rows - you'll get file that you've got in feature and it will be from 1st row till 44th row.)

$>git diff develop...feature
Will compare what was changed in feature from commit that it was branched from develop.
Means it will compare commit where feature was born with TOP of feature.

$>git diff fk4g (HEAD for example)
Will show difference between current working directory changes wih commit.
git diff - defferent with git diff HEAD, without argument - it will show diff with cyrrent index, not commit.
Be aware that these types of commands - ignore untracked files.

$>git diff --cached/--staged HEAD
Show difference beetwen index and HEAD. Useful to see what we will commit after we add changes in index.

$>git diff (nothing - to compare with index, HEAD to compare with head) file.js
$> git diff develop feature file.js (you can add a few files here to save time)
Show changes of some particular file, depending on what you want to see.

$>git diff --name-only e24412
show only files that changed, after that you can look more detailed for file you're interested in.

$>git diff master:file1.js develop:file2.js
compare two different files from two different commits.

$>git diff --no-index file1.js file2.js
compare any two files on machine, no matter what it is, and in our repository or not.

$>git diff --word-diff (--color-words - will show only words without brackets stuff)
compare sentenses, with comfortable, clear difference.

Also you can exend local git config .git/config - with new diff features. i.e. add markdown
hendler (driver) in diff.
[diff "markdown"]
        # POSIX extended
        xfuncname = "^#+[[:space:]]+.+$" (it's for deff header, just a tip to diff be more readable)
        wordRegex = "\\*+|[^[:space:]*]+" (for word, how git will understand that this is a word)
and now you can add a *.md diff=markdown in your .gitattributes.

Also you can setup diff for images, and other non text files. 
For that you can use non-git utilites, and set them to config file
[diff "myOwnDiffTool"]
      command = sh -c 'icdiff "$1" "$4"'
and in gitattributes *.png diff = myOwnDiffTool
Means, that when I will call diff on png file, git will pass arguments (path to diff files,
commits, hashsum and others) to icdiff tool, but we want to have only pathes to files, thats
why we pass to icdiff first and forth arguments.

LOG
Shows commits reachable from HEAD

$>git log
By default it runs with flag --pretty=medium (commitID, author, date, commit message)
$>git log --pretty=oneline (gives us commitID and message) --abbrec-commit (to make commitID short) 
same as 
$>git log --oneline

log is very customizable. i.e.
$>git log --pretty=format:'%h %cd | %s%d [%an]'
Show us custom log info where:
%h - short commitID
%cd - date
%s - commit message first line
%d - decorator string, pointing HEAD, branch etc.
[%an] - author in brackets
We can find all flags in git help log

Also we can edit collors. We can check them in git help config.
normal, black, red, green, yellow, blue, magenta, cyan and white
bold, dim, ul, blink, reverse, italic, and strike
$>git log --pretty=format:'%C(yellow)%h %C(red)%cd | %C(green)%s%d %C(dim green)[%an]'

See git log with changes.
$>git log --patch (-p)

$>git log master
Show commits from master

$>git log master develop --graph ($>git log --all --graph) 
Show branches commits lite tree, graph

$>git log feature ^master
same $>git log master..feature
or if you are in one of needed branch
master$>git log HEAD..feature (same as git log ..feature)
Show commits done after branching from master.
So it show feature commits unreachable from master

oposite:
master$>git log feature..
Shows master commits that isn't reachable from feature branch. cool.

$>git log master...feature --boundary --graph
... - commits reachable from master and feature, but not for both branches same time.
- boundary - will show the commit where branches where divided.

$>git log myFile.js (git log -p myFile.js - with changes made in that file,
--follow - if the file was changed, git findes changes for changed file also)
Shows commits where this file was changed.

If you wanted to see differentse between file in branches
$>git log feature..master myFile.js

Search for commits by message
$>git log --grep 'word from message'
$>git log --grep 'word from message' featureBranch (in some branch)
$>git log --grep 'thisWord|orThisWord' -P -i (Perl friendly reqexp, ignore case)

You want to find all commits where some function was added.
$>git log -GfunctionNameRegexp -p (p - show changes)

More important and pwerfull search - it's you wand to find all changes that was made
in some function. You need to add -L flag and set a regexp to start search from
and regexp where to end. Also it's usefull to set the file you want to search in.
$>git log -L 3,6:somefile.html (set the lines of the file)
$>git log -L '/<head>/','/<\/head>/':somefile.html

Even more effective type of searching
$>git log -L :fynctionNane:file.js
git will try to find function with name and he will think that all of the code before 
next function - is belong to found function.
So it will grab commits even if the space beetwen functions is affected.
But still - it's very effective.
BUT it works only with function declaration. So it better to find:
$>git log -L '/^functionName\(/','/^}/':somefile.js

Search by author name or email, or committer
$>git log --author=Oleh (--author=9000@gmail.com)
$>git log --committer=someoneWhoMadeACommit

By time:
git log --after '2019-03-01' --before '2019-03-02'

BLAME
Show the committer of lines in file.
$>git blame -L 3,6:somefile.html
$ git blame somefile.html --date=short -L 3,6 (with shorted date)

MERGE
We merging develop to feature.
In feature we have commits: init, 1f, 2f.
In develop we have commits: init, 1d, 2d. 
feature>git merge develop
Git will grab TOP of develop (2d) and try to merge it with TOP of feature. 
After resolving conflicts (or not) - merge commit will be created 3mc.
Here we are, feature merged with develop. Log will show:
>3mc
>2d
>1d
>2f
>1f
>init
So when we make merge - we have addition merge commit, and hystory of full development in develop branch
and feature branch. So it's simple to return on state that you like.
MERGE USE - BRING LATEST CHANGES FROM DEVELOP TO FEATURE WITH MERGE COMMIT and have separate history for development

Checkout in branch you want to merge in.
$>git checkout develop
$>git merge featureBranch
BE CAREFULL this will create a merge commit. What happened - git has moved develop HEAD to
featureBranch HEAD. So simply develop became same as featureBranch. (with condition that featureBranch
was branched from develop, and there were no commits in develop branch, so it's not a common case);

git helping us witha merge - storing last before merge commit in current branch in ORIG_HEAD
$>cat .git/ORIG_HEAD - stores last commit
to return develop in previous state we cat use it
$>git branch -f develop ORIG_HEAD - will rectreate develop with HEAD on ORIG_HEAD commit.

So in feature we've done some commits and in develop we've done commits after feature was branched.
And if we moved HEAD of develop to feature - we will lost our commits from develop.
So in this situation git makes true merge and analyze each commit and creates a special merge commit,
were changes from two branches merged together.

develop$>git merge feature

1.Git will find commit where feature was branched from develop. We can do it also with
git merge-base develop feature.
2.Git takes in count 3 version of files:
-1) Base version. It's version of file that was in branching commit.
-2) Ours - we are on develop branch, that means that ours - is version from HEAD (TOP?)
of the develop branch.
-3) Theirs - version from feature HEAD.
So the formula is:
base + ours + theirs = file merged version.

If the auto-merge is failed - that brings us to broken auto-merge state of branch. CONFLICT.
Commit that we are trying to merge with in develop branch - is feature HEAD, and it 
stores in MERGE_HEAD.(.git/MERGE_HEAD).
If in develop file wasn't changed but in feature was - git will try to add changes from feature
to merge commit file version, and visa versa.

So as it was said git trying to help us durring merge.
If it sees that in develop in file a.js on line 1 - was no changes compare with base file, 
but in feature in file a.js line 1 was changed compare to base version - it will add in merge 
commit version of file a.js - changes from feature.
But if in develop a.js 1st line was changed and in feature a.js line 1 was changed - git doesn't know 
what to do - and it calls us to intrude and resolve conflict.

So depend where you are, and in this particular case we merging from develop branch - 
<<<<<<< HEAD (means in current branch HEAD, means in develop code is next)
  some develop changes
============
  some feature changes
>>>>>>> feature (means in theirs, feature HEAD, means in feature code is beyond)

For example we want to take changes that in develop, then
$>git checkout --ours a.js (oposite to checkout --theirs a.js)
Will add in index changes that develop has in a.js file.

If we see that conflicts are pretty serious, and we cannot merge properly - we can:
- hardly reset file or branch to develop HEAD state, means do not do with it anything.
git reset --hard
- if we have some unindex files, and we making a merge - we can use 
git reset --merge (same as git merge --abort)
It will reset all files that was afected by merge to develop HEAD state, but won't touch any
files that was not affected by merging, and was in working directory. Hard reset - will reset all
files to develop HEAD state.

If you want to see 3 variants of file, you can: 
$>git checkout --conflict=diff3 --merge a.js 

So you've changed a file as you waned, delete with hands all those unneeded changes "<<<...", etc.
but you cannot do a coomit now, because when you in merge conflict state, in index - there are
three variants of file existing. 1 - base, 2 - yours, 3 - theirs. you can check it with
$>git show :1:a.js
$>git show :2:a.js
$>git show :3:a.js

That's why we need to add to index only one version. So
$>git add a.js (or add .)

After conflicts are resolved, and all in index, we can do either:
$>git commit (witch make a merge commit and finishes the merge)
or
$>git merge --continue (witch is equal to commit.)

So this new commit, merge commit is special. It has not one, as all regular commits have, but
two ancestors. HEADs of branches that were merged.
We can see that if we make git log --graph --oneline, or git show/log (the last commit will be
Merge: 0cbc23b (ORIG_HEAD, develop) 7c50372(MERGE_HEAD, feature)), so log saying to us - that 
it is a merge commit. Also we can see that diff - is combined by two commits, and commpresed, 
means - diff shows only changes from conflict files. Also "+" is on different positions, means 
+ changes from feature
 +changes that was in deelop

If we want to see changes from develop ORIG_HEAD
$>git show --first-parent

but we can use ^ sigh in diff commant - more usefull for merge commits
$>git diff HEAD^1 (same as HEAD^) - see difference with develop commit parent 
$>git diff HEAD^2 - see difference with feature commit parent
$>git diff HEAD^1^ (same as HEAD^^) - see difference with develop commit previous parent 
$>git diff HEAD^2^ - see difference with feature commit previous parent


Usefull to add --log when you merging. It adds a commit messages from feature branch
to merge commit message. It help you to realise what kind of changes where done by commit
messages, so it's like a little story.
develop$>git merge feature --log=5 (5 last commit messages added from feature branch)

After merge - if we tap git log - it will show all commits from develop? and all commits from
feature. Thats not that we are looking for as usual, so to see commits only from develop
$>git log --oneline --first-parent (with condition that every merge was from develop)

REVERT/CHANGE MERGING
It's the same revert, fact that commit has two parrents - doesn't matter, because merge commit
is only in develop branch - and we can simply reset to commit before
$>git reset --hard @~

Or for example, we reverted, make some changes and wanted to go back on our first commit.
We can find those commits in reflog
$>git reflog -3
b854ccf (HEAD -> develop, origin/develop) HEAD@{0}: commit: first true merge done
fc0a1bf HEAD@{1}: commit (merge): Merge branch 'feature1' into develop
207e6d3 HEAD@{2}: reset: moving to HEAD

$>git reset --hard @{1}
and we will go back on previous merge commit

Situation, developing features were in two branches, in one branch - some function was improved, 
in other - doesn't improved, and added call for not improved function somewhere. And we made a merge.
Git didn't complane about merge conflicts - because there was no conflicts in file, just added
non-improved function call. But code won't work properly. This situation called symantic conflict,
means code is conflicted by sence not by file.
To resolve this situation, we will reset hard on previous commit, and make a merge again but with:

develop$>git merge feature --no-commit
This will make a merge, but without commit in the end. So we will in merge-conflict state, with changes
in index, and have ability to fix all sematic conflicts, and then make a merge commit as we will 
do if there was some file conflict.

Always make a merge commit.
If there were no commits in develop branch since feature branched from it, and there a few commits in 
feature - then merge with fetaure will be just simple moving develop HEAD to feature HEAD, fast forward.
And we have some troubles with it:
- If there is a bug - we cannot understand easily where merge was done - no merge coomit.
- We cannot understand on witch commit we should revert.
So it's better do do merge
develop$>git merge --no-off feature

$>git config merge.ff false (turn off fast forward merging)
$>git branch.develop.mergeoptions '--no-ff' (disable ff for develop)
develop$>git merge --ff feature (enable ff for this merge)

SQUASH
For example you where doing something crazy in feature, a lot off commits, and you are too lazy to make them one.
If you need to merge changes from branch, but don't want whole branch changes - then you can grab changes from branch
and use them in develop. So it's NOT MERGE, it's geting changes from feature into develop index.
develop$>git merge --squash feature
That will add last changes from feature branch to develop index or working directory. After that you can make a 
regular commit in develop branch. So you will have clear develop history and changes from feature.
SQUASH USE - BRING ONLY CHANGES FROM DEVELOP TO FEATURE INDEX, WITHOUT DEVELOP HISTORY.

Be aware that for this merge git doesn't create a MERGE_HEAD with a feature HEAD in it. So you cannot do:
git merge --abort - will be error. (its an alias for: git reset --merge - it will solve problem)

So after resolving conflicts - just make a commit.

Merge driver - it's a technic that git uses to merge files.
We can edit it in .gitattributes
union driver - is pretty weak, it adding every rows with every, it's pretty uncomfortable for code but 
quiet good for some log files, where info only added to the eng for example.
Git also allows you to create your own merge driver.

MERGE STRATEGY
-recursive (default)
-octopus
-ours
-resolve
-subtree

Recursive.
Named like that because it can merge from parents that has same parents each other.
Has features:
-Xours/-Xtheirs - ability to resolve conflicts in favor (пользу) of some branch. So changes that not conflicted
in feature will be merged, but all conflicts resolved in favor of develop, and visa versa.
$>git merge -Xours feature (or -Xtheirs)

-Xrenormalize - if code in feature has different ends of rows and files, we can try to resole it
Also there a opitions to ignore space changes -Xignore-all-space -Xignore-space-change.

-Xno-renames - If in two branches file renamed different, git will notice that and in merge ask
you to resolve this situation, choose the file that should stay. Also cool thing is if we renamed file 
in feature and change it a little bit (less that 50%), and also changed it in develop, but didn't rename
in develop - if we merge feature in develop, file will be renamed, and changes from feature and develop
- will be in it. But that not always great, if we indeed need new file, we can ask git stop to watch renaming
develop$>git merge -Xno-renames feature
We can ask git to find renamed, as we think files
$>develop$>git merge -Xfind-renames=80 feature (set that simularity should be 80%)

-Xsubtree - We can have separate branch connected to our develop. For example some plugin.
for subtree - we need to have some folder. We can develop subtree separatly, and merge time to time it to 
develop. For example we can store some big functionality there, that need to be separate.
develop$>git merge -Xsubtree=plugin(path to plugin folder) --allow-unrelated-histories (if first time adding) pluginBranch

Also there another instrument - submodule. it's different, if subtree - is a separate branch connected to develop
then submodule - it is a completely different repository connected to current repository, so it's like a subrepository.

Octopus.
This strategy used when we merge more than two branches.
develop$>git merge feature1 feature2 (merge will be with octopus strategy)
Some disadvantages:
1.If there is a conflict - merge will fail.
2.Harder to abort merge with some specific branch.
This strategy used when you have a lot of branches, that implements different functionality, to save time - you
can merge a few branches at once.

Ours.
Strategy that completely ignores changes from feature branch. To fire - you should choose it by strategy flag.
Different from recursive -Xours (that will add non-conflicts from feature). So basicaly it makes merge but doesn't 
do anything. :-\
develop$>git merge -s ours feature

Resolve / Subtree.
Old strategies, that exist by historical reason. Resolve - changed by recursive, wih flags. Subtree - changed by
recursive with -Xsubtree flag. 

CHERRY-PICK
For example we have two branches, with two versions of our product. Development runs separately in them.
and you realise that you have same bug in two branches. Bug is fixed in branch_v1 - you cannot merge them,
since they are too different, but you can try to cherry-pick fix commit from branch_v1 to branch_v2.
So the main idea is that cherry pick will grab only changes that were done in branch_v2 (fixed bug) and try
to apply them on branch_v1. If changes did not depend on previous branch_v2 features, then it successfully 
add them to develop.
You cannot do the merge --squash - it will grab ALL changes from branch_v2 and you don't want them, even in
your index in branch_v1.
CHERRY PICK USE - GET ONE NEEDED COMMIT TO FEATURE FROM DEVELOP, and don't bring anything else from develop. 

Cherry pick has option to copy a few commits
$>git cherry-pick -x 2j3h 5j56h 
$>git cherry-pick -x develop..feature (all commits from point where feature divided from develop,
all commits that not in develop from feture)
Cherry-pick will crete commits in develop one by one.

We want to chenge something in cherry-pick, so we don't want auto-commit
$>git cherry-pick feature --no-commit (same as -n)

Revert cherry-pick
$>git cherry-pick --abort

If conflict resolved
$>git cherry-pick --continue

If you want to stop cherry-picking, means we don't want to create commits from feature, after resolving current
conflict, we can
$>git cherry-pick --quit

If we made cherry pick and realize that we don't want it. reset hard on some commit behind.

When you no-conflict cherrypicing from some feature - your cherry picked commit is equivalent
to commit from feature. There is a way to see equivalemt commits when you diff some branches
$>git cherry develop feature -v (verbose means with commit message header)
This shows commits from feature "-" means this commit equivalent to some feature branch
"+" means that this commit is the sane as dome
But in git log we have some flags to see the same thing
$ git log feature1...develop --oneline --cherry-mark --left-right
> 553e140 cherry-pick continue (> - right, means develop branch)
> bbe5414 alignment
> 6183d5d cherry pick in progress
< 71gd5ds some feature commit (< - left, means feature branch)
= 22dc57e some fix 
(equal commit with 9abc78c, means cherrypicked, but truly it's doesn't matter where it is since it's equal)
= 9abc78c (feature) some fix

Or you can see commits only from prefer brench --right-only, or --left-only
Or you can even make it simplier with
$ git log feature1...develop --oneline --cherry (--cherry-mark, --right-only, --no-merges in one flag)

REBASE
So as far as I get it.
We rebasing develop to feature.
In feature we have commits: init, 1f, 2f.
In develop we have commits: init, 1d, 2d. 
feature>git rebase develop
Git will grab TOP of develop (2d) and try to merge it with 1f. 
After resolving conflicts (or not) - 1f - is no longer 1f - it rebased with 2d - becomes 1fd.
Contiue to rebasing - git grab 2d and merge it with 2f, after resolving, 2f no more - becomes 2fd.
Here we are, feature merged with develop, and with rewrited history. Log will show
>2fd (ex 2f)
>1fd (ex 1f)
>2d
>1d
>init
When we make rebase - we rewriting our history of development depending on changes from rebasing branch.
So we will have cleaner history without additional merge commits, but it will be more coplicated to revert
changes, since there like one straight history of "our" (rewritted) development, so our original development
is no longer exist - it rewritted with rebased branch.
REBASE USE - BRING LATEST CHANGES FROM DEVELOP TO FEATURE WITHOUT EXTRA COMMIT (but we sacrifice feature commits)
PROBLEMS in front of merge:
1. PROHIBITED to rebase publick branches, where not only you working in. So rebase just for your local branches. 
So you cannot rebase feature in develop, because develop - is common, and you'll rewrite his commits with your changes.
2. When something goes wrong - and in initial commit after rebase - something broken, we have a bunch of rewritted
broken commits, and it's not trivial to revert them, even if we fix something, we still have broken commits in history
whitch is bad thing, we can revert on broken commit, and don't understand why it's not working.
Advantages:
1. Easier to see the changes in pull request, since feature has last develop changes.
2. If you make some commits but not in needed branch, you can easily rebase them to needed one. 

It's a usefull thing if we want to have latest changes from develop, for example, but don't want to have extraCommits
merge commits, than we can REBASE our feature branch on TOP of development. Like we whrap of root of our branch and 
move it on top of development branch with our commits history, that's why we need to rewrite oer commits with 
changes in develop. So the history structure stays the, we still have 1f, 2f, 3f, commits but they are changed.

feature>git rebase develop
There two phases of rebase: 
1. It will grab TOP of develop (2d) and try to merge it with BOTTOM (1f) of feature, when conflicts are solved - new
1fd commit is born, insteed of old 1f.
2. Since we have new BOTTOM of the feature branch, we need to rewrite all development in our feature, that's why
git applying one by one commit in feature to new bottm, so after applying 1fd + 2f = 2fd.

--abort - will decline rebase
--skip - will pass current commit while rebasing

To revert rebase - we need to reset hard on previous HEAD. ORIG_HEAD could work, but it can be changed, so
solid method is to get previous HEAD of feature from reflog
$>git reflog feature -5 (shows 5 last HEADs of feature)
$>git reset --hard feature@{1}

We can set a command for testing each rebased commit, to reduce faling of our code. 